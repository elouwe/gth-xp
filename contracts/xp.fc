#include "stdlib.fc";

;; ───────── Constants ─────────
const int OP_ADD_XP        = 0x1234;
const int CONTRACT_VERSION = 1;
const int ERR_NOT_OWNER    = 401;
const int ERR_OVERFLOW     = 402;

;; ─────── Storage Helpers ───────
(slice, int, cell) _load_state() inline {
    cell raw = get_data();
    if (null?(raw)) {
        return (null(), CONTRACT_VERSION, null());
    }
    slice s     = raw.begin_parse();
    slice owner = s~load_msg_addr();
    int   ver   = s~load_uint(16);
    cell  dict  = s~load_dict();
    return (owner, ver, dict);
}

() _store_state(slice owner, int ver, cell dict) impure inline {
    set_data(
        begin_cell()
            .store_slice(owner)
            .store_uint(ver, 16)
            .store_dict(dict)
        .end_cell()
    );
}

;; ───────── Entry Point ─────────
() recv_internal(int _msg_val, cell msg, slice body) impure {
    if (slice_bits(body) == 0) {
        accept_message();
        slice cs     = msg.begin_parse();
        cs~load_uint(4);         ;; flags
        slice sender = cs~load_msg_addr();
        cs~load_coins();
        cs~load_uint(64);
        cs~load_uint(32);
        var (owner0, ver0, dict0) = _load_state();
        if (slice_bits(owner0) == 0) {
            _store_state(sender, CONTRACT_VERSION, dict0);
        }
        return ();
    }
    int op = body~load_uint(32);
    if (op == OP_ADD_XP) {
        slice user_addr = body~load_msg_addr();
        int   amount    = body~load_uint(64);
        slice cs       = msg.begin_parse();
        cs~load_uint(4);
        slice sender   = cs~load_msg_addr();
        cs~load_coins();
        cs~load_uint(64);
        cs~load_uint(32);
        var (owner, ver, dict) = _load_state();
        throw_unless(ERR_NOT_OWNER, sender.slice_hash() == owner.slice_hash());
        accept_message();
        int key = user_addr.slice_hash();
        var (v, found) = dict.udict_get?(256, key);
        int old_xp = found ? v~load_uint(64) : 0;
        int new_xp = old_xp + amount;
        throw_unless(ERR_OVERFLOW, new_xp >= old_xp);
        throw_unless(ERR_OVERFLOW, new_xp <= 18446744073709551615);
        builder b = begin_cell();
        b.store_uint(new_xp, 64);
        dict = dict.udict_set_builder(256, key, b);
        _store_state(owner, ver, dict);
    }
}

;; ───────── Get Methods ─────────
(int) get_xp(slice args) impure method_id {
    ;; Проверка на пустые аргументы
    if (slice_bits(args) == 0) {
        return 0;
    }
    
    try {
        slice user_addr = args~load_msg_addr();
        int key = user_addr.slice_hash();
        var (_o, _v, dict) = _load_state();
        if (null?(dict)) { return 0; }
        var (v, found) = dict.udict_get?(256, key);
        return found ? v~load_uint(64) : 0;
    }
    catch (e) {  
        return 0;
    }
}

(cell) get_xp_dict() impure method_id {
    var (_o, _v, dict) = _load_state();
    return dict;
}

(int) get_xp_by_key(slice args) impure method_id {
  int key = args~load_uint(256);
  var (_o,_v, dict) = _load_state();
  if (null?(dict)) { return 0; }
  var (v,found) = dict.udict_get?(256, key);
  return found ? v~load_uint(64) : 0;
}

(slice) get_owner() impure method_id {
    var (owner, _v, _d) = _load_state();
    return owner;
}

(int) get_version() impure method_id {
    var (_o, ver, _d) = _load_state();
    return ver;
}

(int) get_level(int xp) impure method_id {
    throw_unless(301, xp >= 0);
    if (xp < 100)  { return 0; }
    if (xp < 250)  { return 1; }
    if (xp < 500)  { return 2; }
    return 3;
}

(int) get_rank(int xp) impure method_id { return get_level(xp); }

(int) get_reputation(int xp, int d, int r, int bw) impure method_id {
    throw_unless(310, (xp >= 0) & (d >= 0) & (r >= 0) & (bw >= 0));
    int score = (xp / 10) + (d * 2) + (r * 5) - (bw * 10) + 18;
    if (score < 0)  { score = 0; }
    if (score > 100){ score = 100; }
    return score;
}